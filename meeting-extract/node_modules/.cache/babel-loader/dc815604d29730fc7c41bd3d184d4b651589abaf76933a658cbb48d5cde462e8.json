{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst react_pdf_1 = require(\"react-pdf\");\n// Path to the pdf.worker.js file\nreact_pdf_1.pdfjs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${react_pdf_1.pdfjs.version}/pdf.worker.mjs`;\n/**\n * Extracts text content from a PDF file.\n * @param {File | Blob | MediaSource} file - The PDF file to extract text from.\n * @returns {Promise<string>} A promise that resolves with the extracted text content.\n */\nconst pdfToText = file => __awaiter(void 0, void 0, void 0, function* () {\n  // Create a blob URL for the PDF file\n  const blobUrl = URL.createObjectURL(file);\n  // Load the PDF file\n  const loadingTask = react_pdf_1.pdfjs.getDocument(blobUrl);\n  let extractedText = \"\";\n  let hadParsingError = false;\n  try {\n    const pdf = yield loadingTask.promise;\n    const numPages = pdf.numPages;\n    // Iterate through each page and extract text\n    for (let pageNumber = 1; pageNumber <= numPages; pageNumber++) {\n      const page = yield pdf.getPage(pageNumber);\n      const textContent = yield page.getTextContent();\n      const pageText = textContent.items.map(item => \"str\" in item ? item.str : \"\").join(\" \");\n      extractedText += pageText;\n    }\n  } catch (error) {\n    hadParsingError = true;\n    console.error(\"Error extracting text from PDF:\", error);\n  }\n  // Clean up the blob URL\n  URL.revokeObjectURL(blobUrl);\n  // Free memory from loading task\n  loadingTask.destroy();\n  if (!hadParsingError) {\n    return extractedText;\n  }\n});\nexports.default = pdfToText;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","react_pdf_1","require","pdfjs","GlobalWorkerOptions","workerSrc","version","pdfToText","file","blobUrl","URL","createObjectURL","loadingTask","getDocument","extractedText","hadParsingError","pdf","promise","numPages","pageNumber","page","getPage","textContent","getTextContent","pageText","items","map","item","str","join","error","console","revokeObjectURL","destroy","default"],"sources":["/Users/crystalcho/node_modules/react-pdftotext/dist/index.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst react_pdf_1 = require(\"react-pdf\");\n// Path to the pdf.worker.js file\nreact_pdf_1.pdfjs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${react_pdf_1.pdfjs.version}/pdf.worker.mjs`;\n/**\n * Extracts text content from a PDF file.\n * @param {File | Blob | MediaSource} file - The PDF file to extract text from.\n * @returns {Promise<string>} A promise that resolves with the extracted text content.\n */\nconst pdfToText = (file) => __awaiter(void 0, void 0, void 0, function* () {\n    // Create a blob URL for the PDF file\n    const blobUrl = URL.createObjectURL(file);\n    // Load the PDF file\n    const loadingTask = react_pdf_1.pdfjs.getDocument(blobUrl);\n    let extractedText = \"\";\n    let hadParsingError = false;\n    try {\n        const pdf = yield loadingTask.promise;\n        const numPages = pdf.numPages;\n        // Iterate through each page and extract text\n        for (let pageNumber = 1; pageNumber <= numPages; pageNumber++) {\n            const page = yield pdf.getPage(pageNumber);\n            const textContent = yield page.getTextContent();\n            const pageText = textContent.items\n                .map((item) => (\"str\" in item ? item.str : \"\"))\n                .join(\" \");\n            extractedText += pageText;\n        }\n    }\n    catch (error) {\n        hadParsingError = true;\n        console.error(\"Error extracting text from PDF:\", error);\n    }\n    // Clean up the blob URL\n    URL.revokeObjectURL(blobUrl);\n    // Free memory from loading task\n    loadingTask.destroy();\n    if (!hadParsingError) {\n        return extractedText;\n    }\n});\nexports.default = pdfToText;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}